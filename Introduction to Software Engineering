Course 2: Introduction to Software Engineering

Module 1: SDLC - THE SOFTWARE DEVELOPMENT LIFECYCLE

Software Development Lifecycle (SDLC).
- The Software Development Lifecycle is like a recipe for creating software. Just as a chef follows steps to prepare a delicious meal, software developers follow a series of stages to build software. These stages typically include planning, designing, coding, testing, and maintaining the software.

What is Software Engineering?
- Software engineering involves using programming languages and engineering principles to create products like web apps, mobile apps, and operating systems.
- It encompasses a full lifecycle from design and implementation to maintenance and improvement of software.

Roles in Software Engineering
- Different roles include front-end, back-end, security, mobile, test, full-stack, DevOps, cloud data, and machine learning engineers.
- The distinction between software engineers and developers is discussed, with engineers taking on broader responsibilities including system design and architecture.

Creative Process in Software Engineering
- Software engineering is described as a creative process that requires envisioning and supporting software throughout its lifecycle.
- The importance of understanding the software before coding is emphasized, along with the need for various considerations during the engineering process.

Phases of the SDLC
- The SDLC consists of six phases: planning, design, development, testing, deployment, and maintenance.
- Each phase is distinct, with no overlap of tasks between them, although some organizations may use different names or have variations in the number of phases.

Planning and Design
- In the planning phase, requirements are gathered, analyzed, and documented, leading to the creation of a Software Requirements Specification (SRS) document.
- The design phase involves developing the software architecture based on the SRS, with prototypes created for demonstration and feedback.

Development and Testing
- The development phase is where coding occurs, guided by the design document, using various programming tools and languages.
- The testing phase follows development, ensuring the code is stable and meets requirements through various testing methods.

Deployment and Maintenance
- During the deployment phase, the application is released to users, often in stages, starting with user acceptance testing.
- The maintenance phase addresses any bugs or issues post-deployment and may lead to further enhancements, restarting the SDLC cycle as needed.

Requirements of Software Engineering

Gathering Process
- Involves six steps: identifying stakeholders, establishing goals and objectives, eliciting requirements, documenting requirements, analyzing and confirming requirements, and prioritizing.
- Stakeholders include decision-makers, end-users, and other personnel from the organization requesting the software.

Key Documentation
- User Requirement Specification (URS): Captures user stories detailing who the user is, what function needs to be performed, and why.
- Software Requirement Specification (SRS): Documents functional, external, system, and non-functional requirements, including purpose, scope, constraints, and dependencies.
- System Requirement Specification (SysRS): Broader than SRS, outlining system capabilities, interfaces, user characteristics, and various requirements including performance and security.

V-Shape Model
Plan                                                   Acceptance Testing
    System Design                                System Testing
           Architecture Design            Integration Testing
                    Module Design      Unit Testing
                                 Coding


Software Versions
- Each version number is a unique label that helps users and developers know what changes have been made over time. For example, if you see a version number like 1.0, it means that this is the first official release of the software, with no updates or fixes yet. If you see a number like 2.3.1, it indicates that there have been major changes (the 2), some minor updates (the 3), and a few small fixes (the 1).
- The first release of software might be labeled as 1.0, while beta versions can be lower than 1, such as 0.9.

Sofware Testing
- Functional Testing: This checks if the software performs its intended functions correctly, focusing on inputs and outputs without looking at the internal code.
- Non-Functional Testing: This evaluates the software's performance attributes, such as speed, security, and scalability, under various conditions.
- Regression Testing: This ensures that recent changes or bug fixes do not negatively impact existing functionalities.

Testing Levels
- Unit Testing: Tests individual sections of code to catch errors early in the development phase.
- Integration Testing: Checks for errors when combining multiple code modules to ensure they work together correctly.
- System Testing: Validates the complete software product against specified requirements in a staging environment.
- Acceptance Testing: Confirms that the software meets user needs and requirements, typically conducted by customers or stakeholders.

Software Documentation
- Documentation can be in three formats: written, video, or graphical.
- It is categorized into product documentation (related to product functionality) and process documentation (describing how to complete tasks).

Categories of Product Documentation
- Five main types include requirements documentation (features and functionality), design documentation (how software will be built), technical documentation (code comments and working papers), quality assurance documentation (testing strategies and metrics), and user documentation (guides for end-users).

Standard Operating Procedures (SOPs)
- SOPs provide detailed, step-by-step instructions for specific organizational tasks, complementing process documentation.
- Keeping documentation up to date is crucial, especially during the maintenance phase of the SDLC, to ensure accuracy and relevance.

Roles in Software Engineering Projects
- Project Manager/Scrum Master: This person keeps everything organized and makes sure the team communicates well. They help plan the project and solve any big issues that come up.
- Stakeholders: These are the people who will use the software or have a say in what it should do. They provide important feedback and help define what the project needs to achieve.
- Software Architect: This role involves designing the overall structure of the software, like an architect designing a building. They ensure that everything fits together well.
- UX Designer: This person focuses on how users will interact with the software, making it easy and enjoyable to use.
- Software Developer: These are the coders who write the actual software, turning ideas into a working product.
- Tester/QA Engineer: They check the software for bugs and ensure it meets the requirements before itâ€™s released.
- Site Reliability Engineer: This role combines development and operations, ensuring the software runs smoothly and reliably.
- Product Manager: They have a vision for the product and guide the team to make sure it meets users' needs.
- Technical Writer: This person creates user manuals and documentation to help users understand how to use the software.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Module 2: INTRODUCTION TO SOFTWARE DEVELOPMENT

Pair Programming
Types of Pair Programming
- Driver/Navigator Style: One developer types the code (driver) while the other reviews and guides (navigator). They regularly switch roles to keep both engaged.
- Ping-Pong Style: Developers alternate between writing tests and code for each task, ensuring both contribute equally.
- Strong Style: A more experienced developer guides a junior developer, allowing the latter to learn through observation and implementation.

Benefits of Pair Programming
- Enhances knowledge sharing and skill development between developers.
- Improves code quality by reducing errors and enabling on-the-fly code reviews.
- Fosters better communication and problem-solving skills.

Challenges of Pair Programming
- Requires sustained focus, which can be exhausting.
- Scheduling conflicts may arise due to personal commitments.
- Personality clashes can hinder collaboration, and noise from multiple pairs can disrupt others.

Software Stacks
- A software stack consists of various technologies, including programming languages and frameworks, organized in layers to support application development.
- The higher layers interact with users, while the lower layers connect with hardware.

Types of Software Stacks
- Common examples include the LAMP stack (Linux, Apache, MySQL, PHP) and the MEAN stack (MongoDB, Express.js, Angular.js, Node.js).
- Each stack has its own advantages and is suited for different types of applications.

Benefits and Challenges
- Software stacks can be flexible, allowing developers to choose components that best fit their needs.
- However, some stacks may have limitations, such as compatibility issues or performance constraints.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
Module 3: BASICS OF PROGRAMMING

Interpreted Programming Languages
- These languages, such as Python and JavaScript, are executed line by line by an interpreter, which translates the code into machine code on the fly.
- They are often easier to learn and more versatile, allowing for quick testing and execution, but may run slower than compiled languages.

Compiled Programming Languages
- Languages like C, C++, and Java are compiled into machine code before execution, creating a single executable file.
- Compiled programs run faster and are used for more complex applications, such as operating systems and large software projects.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Module 4:SOFTWARE ARCHITECTURE, DESIGN AND PATTERNS

Understanding Software Architecture
- Software architecture serves as a blueprint for the software system, outlining how components interact and behave.
- It captures early design decisions that are often difficult and costly to change later in the development process.

Importance of Well-Designed Architecture
- A well-structured architecture balances stakeholder needs and facilitates communication among team members.
- It influences technology stack choices and accommodates changing requirements during development.

Artifacts of Software Architecture
- Key artifacts produced during architectural design include the Software Design Document (SDD), architectural diagrams, and Unified Modeling Language (UML) diagrams.
- These artifacts help communicate design decisions and specifications to stakeholders and guide the implementation process.

Structured Design
- Breaks down software problems into smaller, organized modules and sub-modules.
- Emphasizes cohesion (related elements grouped together) and loose coupling (minimal impact of changes between modules).

Unified Modeling Language (UML)
- A standardized way to visually represent software architecture, design, and implementation.
- Helps in planning features, onboarding new team members, and facilitating communication between technical and non-technical audiences.

Behavioral Models
- Describe what a system does without detailing how it does it.
- Includes state transition diagrams (showing system states and transitions) and interaction diagrams (visualizing object communication over time).

Understanding Objects and Classes
- Objects contain data and behaviors that define their actions.
- Classes serve as blueprints for creating specific objects, known as instances.

Class Diagrams in OOAD
- Class diagrams visually represent the structure of a software system, showing how classes relate to one another.
- Each class in a diagram includes its attributes (properties and methods) and illustrates relationships, such as inheritance.

Purpose of OOAD
- OOAD helps in planning software systems by breaking them down into interacting objects.
- It allows multiple developers to work on different parts of an application simultaneously, enhancing collaboration and efficiency.

Component Based Architecture
- A component in software architecture is an individual unit of functionality that is designed to perform a specific task within an application. 

Characteristics of Components
- Reusable: Designed to be used in multiple applications.
- Replaceable: Can be easily swapped with another component.
- Independent: Functions without dependencies on other components.
- Extensible: Allows for adding new features without altering existing functionality.
- Encapsulated: Hides internal details and exposes only necessary interfaces.
- Non-context specific: Operates in various environments, with its state set externally.


Module 5: Job Opportunities and Skillsets in Software Engineering

Module 6: Final Activity and Quiz

