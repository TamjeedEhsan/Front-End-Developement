Course 2: Introduction to Software Engineering

Module 1: SDLC - THE SOFTWARE DEVELOPMENT LIFECYCLE

Software Development Lifecycle (SDLC).
- The Software Development Lifecycle is like a recipe for creating software. Just as a chef follows steps to prepare a delicious meal, software developers follow a series of stages to build software. These stages typically include planning, designing, coding, testing, and maintaining the software.

What is Software Engineering?
- Software engineering involves using programming languages and engineering principles to create products like web apps, mobile apps, and operating systems.
- It encompasses a full lifecycle from design and implementation to maintenance and improvement of software.

Roles in Software Engineering
- Different roles include front-end, back-end, security, mobile, test, full-stack, DevOps, cloud data, and machine learning engineers.
- The distinction between software engineers and developers is discussed, with engineers taking on broader responsibilities including system design and architecture.

Creative Process in Software Engineering
- Software engineering is described as a creative process that requires envisioning and supporting software throughout its lifecycle.
- The importance of understanding the software before coding is emphasized, along with the need for various considerations during the engineering process.

Phases of the SDLC
- The SDLC consists of six phases: planning, design, development, testing, deployment, and maintenance.
- Each phase is distinct, with no overlap of tasks between them, although some organizations may use different names or have variations in the number of phases.

Planning and Design
- In the planning phase, requirements are gathered, analyzed, and documented, leading to the creation of a Software Requirements Specification (SRS) document.
- The design phase involves developing the software architecture based on the SRS, with prototypes created for demonstration and feedback.

Development and Testing
- The development phase is where coding occurs, guided by the design document, using various programming tools and languages.
- The testing phase follows development, ensuring the code is stable and meets requirements through various testing methods.

Deployment and Maintenance
- During the deployment phase, the application is released to users, often in stages, starting with user acceptance testing.
- The maintenance phase addresses any bugs or issues post-deployment and may lead to further enhancements, restarting the SDLC cycle as needed.

Requirements of Software Engineering

Gathering Process
- Involves six steps: identifying stakeholders, establishing goals and objectives, eliciting requirements, documenting requirements, analyzing and confirming requirements, and prioritizing.
- Stakeholders include decision-makers, end-users, and other personnel from the organization requesting the software.

Key Documentation
- User Requirement Specification (URS): Captures user stories detailing who the user is, what function needs to be performed, and why.
- Software Requirement Specification (SRS): Documents functional, external, system, and non-functional requirements, including purpose, scope, constraints, and dependencies.
- System Requirement Specification (SysRS): Broader than SRS, outlining system capabilities, interfaces, user characteristics, and various requirements including performance and security.

V-Shape Model
Plan                                                   Acceptance Testing
    System Design                                System Testing
           Architecture Design            Integration Testing
                    Module Design      Unit Testing
                                 Coding


Software Versions
- Each version number is a unique label that helps users and developers know what changes have been made over time. For example, if you see a version number like 1.0, it means that this is the first official release of the software, with no updates or fixes yet. If you see a number like 2.3.1, it indicates that there have been major changes (the 2), some minor updates (the 3), and a few small fixes (the 1).
- The first release of software might be labeled as 1.0, while beta versions can be lower than 1, such as 0.9.

Sofware Testing
- Functional Testing: This checks if the software performs its intended functions correctly, focusing on inputs and outputs without looking at the internal code.
- Non-Functional Testing: This evaluates the software's performance attributes, such as speed, security, and scalability, under various conditions.
- Regression Testing: This ensures that recent changes or bug fixes do not negatively impact existing functionalities.

Testing Levels
- Unit Testing: Tests individual sections of code to catch errors early in the development phase.
- Integration Testing: Checks for errors when combining multiple code modules to ensure they work together correctly.
- System Testing: Validates the complete software product against specified requirements in a staging environment.
- Acceptance Testing: Confirms that the software meets user needs and requirements, typically conducted by customers or stakeholders.

Software Documentation
- Documentation can be in three formats: written, video, or graphical.
- It is categorized into product documentation (related to product functionality) and process documentation (describing how to complete tasks).

Categories of Product Documentation
- Five main types include requirements documentation (features and functionality), design documentation (how software will be built), technical documentation (code comments and working papers), quality assurance documentation (testing strategies and metrics), and user documentation (guides for end-users).

Standard Operating Procedures (SOPs)
- SOPs provide detailed, step-by-step instructions for specific organizational tasks, complementing process documentation.
- Keeping documentation up to date is crucial, especially during the maintenance phase of the SDLC, to ensure accuracy and relevance.

Roles in Software Engineering Projects
- Project Manager/Scrum Master: This person keeps everything organized and makes sure the team communicates well. They help plan the project and solve any big issues that come up.
- Stakeholders: These are the people who will use the software or have a say in what it should do. They provide important feedback and help define what the project needs to achieve.
- Software Architect: This role involves designing the overall structure of the software, like an architect designing a building. They ensure that everything fits together well.
- UX Designer: This person focuses on how users will interact with the software, making it easy and enjoyable to use.
- Software Developer: These are the coders who write the actual software, turning ideas into a working product.
- Tester/QA Engineer: They check the software for bugs and ensure it meets the requirements before itâ€™s released.
- Site Reliability Engineer: This role combines development and operations, ensuring the software runs smoothly and reliably.
- Product Manager: They have a vision for the product and guide the team to make sure it meets users' needs.
- Technical Writer: This person creates user manuals and documentation to help users understand how to use the software.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Module 2: INTRODUCTION TO SOFTWARE DEVELOPMENT

Pair Programming
Types of Pair Programming
- Driver/Navigator Style: One developer types the code (driver) while the other reviews and guides (navigator). They regularly switch roles to keep both engaged.
- Ping-Pong Style: Developers alternate between writing tests and code for each task, ensuring both contribute equally.
- Strong Style: A more experienced developer guides a junior developer, allowing the latter to learn through observation and implementation.

Benefits of Pair Programming
- Enhances knowledge sharing and skill development between developers.
- Improves code quality by reducing errors and enabling on-the-fly code reviews.
- Fosters better communication and problem-solving skills.

Challenges of Pair Programming
- Requires sustained focus, which can be exhausting.
- Scheduling conflicts may arise due to personal commitments.
- Personality clashes can hinder collaboration, and noise from multiple pairs can disrupt others.

Software Stacks
- A software stack consists of various technologies, including programming languages and frameworks, organized in layers to support application development.
- The higher layers interact with users, while the lower layers connect with hardware.

Types of Software Stacks
- Common examples include the LAMP stack (Linux, Apache, MySQL, PHP) and the MEAN stack (MongoDB, Express.js, Angular.js, Node.js).
- Each stack has its own advantages and is suited for different types of applications.

Benefits and Challenges
- Software stacks can be flexible, allowing developers to choose components that best fit their needs.
- However, some stacks may have limitations, such as compatibility issues or performance constraints.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
Module 3: BASICS OF PROGRAMMING

Interpreted Programming Languages
- These languages, such as Python and JavaScript, are executed line by line by an interpreter, which translates the code into machine code on the fly.
- They are often easier to learn and more versatile, allowing for quick testing and execution, but may run slower than compiled languages.

Compiled Programming Languages
- Languages like C, C++, and Java are compiled into machine code before execution, creating a single executable file.
- Compiled programs run faster and are used for more complex applications, such as operating systems and large software projects.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Module 4:SOFTWARE ARCHITECTURE, DESIGN AND PATTERNS

Understanding Software Architecture
- Software architecture serves as a blueprint for the software system, outlining how components interact and behave.
- It captures early design decisions that are often difficult and costly to change later in the development process.

Importance of Well-Designed Architecture
- A well-structured architecture balances stakeholder needs and facilitates communication among team members.
- It influences technology stack choices and accommodates changing requirements during development.

Artifacts of Software Architecture
- Key artifacts produced during architectural design include the Software Design Document (SDD), architectural diagrams, and Unified Modeling Language (UML) diagrams.
- These artifacts help communicate design decisions and specifications to stakeholders and guide the implementation process.

Structured Design
- Breaks down software problems into smaller, organized modules and sub-modules.
- Emphasizes cohesion (related elements grouped together) and loose coupling (minimal impact of changes between modules).

Unified Modeling Language (UML)
- A standardized way to visually represent software architecture, design, and implementation.
- Helps in planning features, onboarding new team members, and facilitating communication between technical and non-technical audiences.

Behavioral Models
- Describe what a system does without detailing how it does it.
- Includes state transition diagrams (showing system states and transitions) and interaction diagrams (visualizing object communication over time).

Understanding Objects and Classes
- Objects contain data and behaviors that define their actions.
- Classes serve as blueprints for creating specific objects, known as instances.

Class Diagrams in OOAD
- Class diagrams visually represent the structure of a software system, showing how classes relate to one another.
- Each class in a diagram includes its attributes (properties and methods) and illustrates relationships, such as inheritance.

Purpose of OOAD
- OOAD helps in planning software systems by breaking them down into interacting objects.
- It allows multiple developers to work on different parts of an application simultaneously, enhancing collaboration and efficiency.

Component Based Architecture
- A component in software architecture is an individual unit of functionality that is designed to perform a specific task within an application. 

Characteristics of Components
- Reusable: Designed to be used in multiple applications.
- Replaceable: Can be easily swapped with another component.
- Independent: Functions without dependencies on other components.
- Extensible: Allows for adding new features without altering existing functionality.
- Encapsulated: Hides internal details and exposes only necessary interfaces.
- Non-context specific: Operates in various environments, with its state set externally.

Architectural Patterns

2-Tier Architecture
- Also known as client-server architecture, where the server manages resources and services for multiple clients.
- Example: Text messaging apps where clients send requests to a server.

3-Tier Architecture
- Composed of three layers: presentation (user interface), application (business logic), and data (storage).
- Example: Web applications that separate user interface, processing, and data management.

Peer-to-Peer Architecture
- A decentralized network where nodes act as both clients and servers, sharing resources directly.
- Example: Cryptocurrencies like Bitcoin, where each node contributes to the network.

Event-Driven Architecture
- Focuses on events triggered by user actions or system changes, with producers generating events and consumers processing them.
- Example: Ride-sharing apps that respond to user requests for rides.

Microservices Architecture
- Breaks applications into modular services that communicate through APIs, allowing for flexibility and scalability.
- Example: Social media platforms that offer various services like friend requests and content display.

Combination of Patterns
- Architectural patterns can be combined, but some are not compatible, such as peer-to-peer and 2-tier architectures.

Production Environment Components
- Common components include firewalls, load balancers, web servers, application servers, proxy servers, and database servers.
- Not all components are necessary for every deployment; it depends on the specific environment.

Firewalls and Load Balancers
- A firewall monitors and controls incoming and outgoing network traffic based on security rules, acting as a barrier against threats.
- Load balancers distribute network traffic efficiently among multiple servers to prevent overload and ensure high availability and responsiveness.

Server Types
- Web servers deliver content like web pages and files to clients, responding to requests from web browsers.
- Application servers run business logic and provide applications to clients, enabling interaction with server-side code.
- Proxy servers act as intermediaries between different tiers, handling requests and improving efficiency, privacy, and security.
- Database servers store and manage data, controlled by a database management system (DBMS) that connects applications to the database.

Question 1
Your team is tasked with creating a scalable enterprise application, considering that the earlier design choices will have a long-lasting impact on the applicationâ€™s structure and future development process. Which of the following aspects should a team focus on?
Answer: It represents the earliest design decisions.

Question 2
The architectural design team has completed its design work and is compiling outputs for documentation. Which of the following would be an expected artifact at this stage?
Answer: Unified modeling language (UML) diagrams showing system structure

Question 3
Which of the following best represents the states of login, processing, and log out for the user interaction with the system in various phases?
Answer: A diagram that illustrates different user states and events that trigger state change.

Question 4
A new software team was provided with the unified modeling language (UML) diagram to understand the systemâ€™s components and their interactions in software architecture. What is the benefit of UML diagrams in software architecture?
Answer: They provide a visual overview for onboarding and collaboration.

Question 5
A startup company wants to design an application in which each node captures requests and provides services to the other nodes without a central server. Which of the following architectures is best suited in this scenario?
Answer: Peer-to-peer architecture

Question 6
A software development team wants to represent a hospitalâ€™s patient management system using object-oriented concepts. How will they define the relationship between patient Naya Patel and the patient class in the object-oriented system?
Answer: Naya Patel is an instance of the patient class with specific attribute values.

Question 7
A developer builds a system where the user interface directly communicates with a server that handles data processing. No separate application logic layer is used. What type of architecture is this?
Answer: A 2-tier architecture with client interfaces talking directly to a server

Question 8
You are designing a new social media site and want to build it using modular services that interact via APIs. Which architecture pattern is appropriate for this scenario?
Answer: Microservices architecture

Question 9
While launching an application for public users, it is important to secure their information. Which environment should an organization use to launch this application?
Answer: The production team deploys a fully operational production system for general users.

Question 10
An organization wants to leverage a server that handles business logic and enables communication between users and server-side applications. Which server is best suited for this requirement?
Answer: Application server

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Module 5: JOB OPPOURTUNITIES AND SKILLSETS IN SOFTWARE ENGINEERING

Types of Software Engineers
- Back-end engineers build the systems and networks that support applications.
- Front-end engineers create the user interfaces that users interact with, such as mobile apps and websites.

Daily Tasks and Responsibilities
- Software engineers design new software systems based on user specifications.
- They write and test code, maintain existing software, and document their work for other developers.

Work Environments
- Software engineers can work on various projects, including off-the-shelf software, bespoke solutions for clients, or internal software for organizations.
- They may collaborate on data integration, business logic, and user interfaces within their teams.

Career Progression
- Junior software engineers typically start with limited responsibilities, focusing on coding and testing.
- As they gain experience, they take on more significant roles, including planning and designing software solutions.

Career Path Overview
- Software engineering careers typically follow either a technical or managerial path, depending on individual skills and interests.
- Entry-level positions often start as Junior or Associate Software Engineers, where individuals develop small software components under guidance.

Technical Path Progression
- As a Software Engineer, one becomes more independent, breaking down larger tasks and possibly mentoring juniors.
- Progressing to a Senior Software Engineer involves overseeing entire projects and conducting code reviews, leading to roles like Staff Software Engineer or Principal Engineer.

Managerial Path Progression
- The managerial path may lead to positions such as Technical Lead, Engineering Manager, or Director of Engineering, focusing on team management and project oversight.
- Ultimately, one could reach the role of Chief Technology Officer (CTO), responsible for strategic and technical direction within the organization.

Module 6: Final Activity and Quiz

